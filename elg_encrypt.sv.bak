module elg_encrypt
	(input logic Clk, Reset,
	input logic [255:0]  Gx, Gy, Qx, Qy, message,
	output logic Done,
	output logic [255:0] Cx, Cy, Dx, Dy);

	// Px, Py is bob_point/other person's point i.e. public key.
	// Qx, Qx is shared secret point.
	logic[255:0] messagey;
	/* insert message stuff here; possibly do in C? */
	logic Done_C, Done_D, Done_tempD;
	logic[255:0] tempDx, tempDy, r;
	assign r = 256'd6;
	/* insert rand() function here; outputs r*/
	/* Generates C1 = r*G */
	gen_point gen_C(.Clk, .Reset, .privKey(r), .Done(Done_C), .outX(Cx), .outY(Cy));
	gen_point gen_tempD(.Clk, .Reset(Reset | ~Done_C), .privKey(r), .Done(Done_tempD), .outX(tempDx), outy(tempDy));

	point_add gen_D(.Clk, .Reset(Reset | ~Done_tempD), .Px(tempDx), .Py(tempDy), .Qx(message), .Qy(messagey), .Done(Done_D)
					.Rx(Dx), .Ry(Dy));

	assign Done = Done_D;
	//add #(17) add0(.a(message), .b(256'd7), .sum(message_y));	// based off of y^2 = x^3 + 7. How do I do
	//point_add make_d(.Clk, .Reset, .Px(message), .Py(message_y), .Qx, .Qy, .Done, .Rx(Dx), .Ry(Dy));

endmodule
