import elliptic_curve_structs::*;

module ecdsa_sign_datapath (
    /* wires for signing */
    input logic clk,
    input logic [11:0] message,
    input logic [255:0] priv_key,
    output signature my_signature,
    output logic done_signature
);
secp256k1_parameters params;

logic [255:0] msg_hash_out;
logic done_bob, done_encrypt, done_decrypt, done_chacha;
logic [511:0] stream_out;
logic load_done, done_in;
logic msg_load, seed_load;
secp256k1_parameters my_curve;

// load hash reg once sha256 is done
reg_256 hash_reg(.clk, .Load(done_hash), .Data(hash), .Out(msg_hash_out));

/* ---- SETUP ----- */
// some key d has already been created; see top_level_testbench
// TODO check if random is ok for testbench
logic [255:0] d;
assign d = priv_key;

/* 1) Calculate e = sha256(m) */
/* 2) set z = N-left most bits of e where N = # group order bits (just using hash itself here) */
logic [255:0] hash;
logic done_hash;
sha256 #(.MSG_SIZE(12)) sha256(.clk, .rst(1'b0), .message, .hashed(hash), .done(done_hash));

/* 3) select random integer k from [1, n-1] (use chacha20) */
// TODO use real sources of entropy
chacha chacha20(.clk, .Reset(reset_all),
				.key(chacha_key), .nonce(chacha_nonce), .stream(stream_out), .Done(done_chacha));
reg_256 chacha_reg(.clk, .Load(done_chacha), .Data(stream_out[255:0]), .Out(blinding_k));
logic [255:0] blinding_k;

/* 4) calculate curve point (x, y) = k*G */
logic done_gen_point;
curve_point pub_point;
gen_point gen_point (.clk, .Reset(reset_all), .privKey(blinding_k), .out_point(pub_point), .Done(done_gen_point));

/* 5) calculate r = x mod n. If r == 0, go to step 3 */
/* 6) calculate s = inv_k*(z + r*d_a) mod n. if s = 0, go back to 3. */
logic temp_done_signature;
logic [255:0] created_signature;
logic [512:0] mod_in;
// TODO multiplication is very costly; reduce maybe?
assign mod_in = msg_hash_out + r*d;
modular_inverse (.clk, .Reset(reset_all), .in(mod_in),
                .out(created_signature), .Done(temp_done_signature));

enum logic [2:0] {
    idle,
    finish_signature,
    rst_states
} state, next_state;
// idle is for normal execution

always_comb begin : state_actions

    done_signature = 1'b0;
    reset_all = 1'b0;

    case(state)
    begin
        idle: ;

        finish_signature : begin
            done_signature = 1'b1;
            my_signature = created_signature;
            reset_all = 1'b1;
        end

        rst_states : begin
            reset_all = 1'b1;
            chacha_key = $random(1, params.n);
            chacha_nonce = $random(1, params.n);
        end
    endcase

end

always_comb begin : next_state_logic
    next_state = state;

    idle : begin
        if(temp_done_signature) next_state = finish_signature;
    end
    finish_signature : if(created_signature == 0) next_state = rst_states;
    rst_states : next_state = idle;
end

always_ff @(posedge clk)
begin : next_state_assignment
    state <= next_state;
end

endmodule : ecdsa_sign_datapath
